"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanadaCorporateTaxServiceImpl = void 0;
class CanadaCorporateTaxServiceImpl {
    constructor(input, rules) {
        this._input = input;
        this._rules = rules;
    }
    calculate() {
        const result = this.applyRules(this._rules, this._input);
        const totalTax = result.tax;
        return {
            corporateTax: totalTax,
            effectiveTaxRate: this._input.taxableIncome > 0
                ? (totalTax / this._input.taxableIncome) * 100
                : 0,
            breakdowns: result.breakdowns,
        };
    }
    applyRules(rules, input) {
        const regime = input.isSmallBusiness
            ? rules.regimes.smallBusiness
            : rules.regimes.general;
        if (regime.type === 'flat') {
            const tax = input.taxableIncome * regime.rate;
            return {
                tax,
                breakdowns: [{ from: '0', to: 'Above', rate: regime.rate, amount: tax }],
            };
        }
        if (regime.type === 'progressive') {
            let remaining = input.taxableIncome;
            let tax = 0;
            const breakdowns = [];
            for (const bracket of regime.brackets) {
                if (remaining <= 0)
                    break;
                const upper = bracket.to ?? Infinity;
                const taxable = Math.min(upper - bracket.from, remaining);
                const bracketTax = taxable * bracket.rate;
                tax += bracketTax;
                remaining -= taxable;
                breakdowns.push({
                    from: `${bracket.from}`,
                    to: `${bracket.to ?? 'Above'}`,
                    rate: bracket.rate,
                    amount: bracketTax,
                });
            }
            return { tax, breakdowns };
        }
        throw new Error('Unsupported regime type');
    }
}
exports.CanadaCorporateTaxServiceImpl = CanadaCorporateTaxServiceImpl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FuYWRhQ29ycG9yYXRlVGF4U2VydmljZUltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29ycG9yYXRlL2NhbmFkYS9DYW5hZGFDb3Jwb3JhdGVUYXhTZXJ2aWNlSW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFJQSxNQUFhLDZCQUE2QjtJQUl0QyxZQUFZLEtBQVksRUFBRSxLQUFZO1FBQ2xDLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxTQUFTO1FBQ0wsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV6RCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBRTVCLE9BQU87WUFDSCxZQUFZLEVBQUUsUUFBUTtZQUN0QixnQkFBZ0IsRUFDWixJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsR0FBRyxDQUFDO2dCQUN6QixDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHO2dCQUM5QyxDQUFDLENBQUMsQ0FBQztZQUNYLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtTQUNoQyxDQUFDO0lBQ04sQ0FBQztJQUVPLFVBQVUsQ0FBQyxLQUFZLEVBQUUsS0FBWTtRQUN6QyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsZUFBZTtZQUNoQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhO1lBQzdCLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUU1QixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDekIsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQzlDLE9BQU87Z0JBQ0gsR0FBRztnQkFDSCxVQUFVLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUM7YUFDM0UsQ0FBQztRQUNOLENBQUM7UUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssYUFBYSxFQUFFLENBQUM7WUFDaEMsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQztZQUNwQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFDWixNQUFNLFVBQVUsR0FBZ0IsRUFBRSxDQUFDO1lBRW5DLEtBQUssTUFBTSxPQUFPLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNwQyxJQUFJLFNBQVMsSUFBSSxDQUFDO29CQUFFLE1BQU07Z0JBRTFCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxFQUFFLElBQUksUUFBUSxDQUFDO2dCQUNyQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUUxRCxNQUFNLFVBQVUsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztnQkFDMUMsR0FBRyxJQUFJLFVBQVUsQ0FBQztnQkFDbEIsU0FBUyxJQUFJLE9BQU8sQ0FBQztnQkFFckIsVUFBVSxDQUFDLElBQUksQ0FBQztvQkFDWixJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFO29CQUN2QixFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxJQUFJLE9BQU8sRUFBRTtvQkFDOUIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO29CQUNsQixNQUFNLEVBQUUsVUFBVTtpQkFDckIsQ0FBQyxDQUFDO1lBQ1AsQ0FBQztZQUVELE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUM7UUFDL0IsQ0FBQztRQUVELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUMvQyxDQUFDO0NBQ0o7QUFqRUQsc0VBaUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUnVsZXMsIElucHV0LCBSZXN1bHQsIFByb2dyZXNzaXZlVGF4QnJhY2tldCB9IGZyb20gJy4vZG9tYWluL3R5cGVzJztcbmltcG9ydCB7IENhbmFkYUNvcnBvcmF0ZVRheFNlcnZpY2UgfSBmcm9tICcuL0NhbmFkYUNvcnBvcmF0ZVRheFNlcnZpY2UnO1xuaW1wb3J0IHsgQnJlYWtkb3duIH0gZnJvbSAnLi4vZG9tYWluL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIENhbmFkYUNvcnBvcmF0ZVRheFNlcnZpY2VJbXBsIGltcGxlbWVudHMgQ2FuYWRhQ29ycG9yYXRlVGF4U2VydmljZSB7XG4gICAgcHJpdmF0ZSBfaW5wdXQ6IElucHV0O1xuICAgIHByaXZhdGUgX3J1bGVzOiBSdWxlcztcblxuICAgIGNvbnN0cnVjdG9yKGlucHV0OiBJbnB1dCwgcnVsZXM6IFJ1bGVzKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX3J1bGVzID0gcnVsZXM7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlKCk6IFJlc3VsdCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXBwbHlSdWxlcyh0aGlzLl9ydWxlcywgdGhpcy5faW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IHRvdGFsVGF4ID0gcmVzdWx0LnRheDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29ycG9yYXRlVGF4OiB0b3RhbFRheCxcbiAgICAgICAgICAgIGVmZmVjdGl2ZVRheFJhdGU6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQudGF4YWJsZUluY29tZSA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyAodG90YWxUYXggLyB0aGlzLl9pbnB1dC50YXhhYmxlSW5jb21lKSAqIDEwMFxuICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBicmVha2Rvd25zOiByZXN1bHQuYnJlYWtkb3ducyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFwcGx5UnVsZXMocnVsZXM6IFJ1bGVzLCBpbnB1dDogSW5wdXQpOiB7IHRheDogbnVtYmVyOyBicmVha2Rvd25zOiBCcmVha2Rvd25bXSB9IHtcbiAgICAgICAgY29uc3QgcmVnaW1lID0gaW5wdXQuaXNTbWFsbEJ1c2luZXNzXG4gICAgICAgICAgICA/IHJ1bGVzLnJlZ2ltZXMuc21hbGxCdXNpbmVzc1xuICAgICAgICAgICAgOiBydWxlcy5yZWdpbWVzLmdlbmVyYWw7XG5cbiAgICAgICAgaWYgKHJlZ2ltZS50eXBlID09PSAnZmxhdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRheCA9IGlucHV0LnRheGFibGVJbmNvbWUgKiByZWdpbWUucmF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGF4LFxuICAgICAgICAgICAgICAgIGJyZWFrZG93bnM6IFt7IGZyb206ICcwJywgdG86ICdBYm92ZScsIHJhdGU6IHJlZ2ltZS5yYXRlLCBhbW91bnQ6IHRheCB9XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnaW1lLnR5cGUgPT09ICdwcm9ncmVzc2l2ZScpIHtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBpbnB1dC50YXhhYmxlSW5jb21lO1xuICAgICAgICAgICAgbGV0IHRheCA9IDA7XG4gICAgICAgICAgICBjb25zdCBicmVha2Rvd25zOiBCcmVha2Rvd25bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyYWNrZXQgb2YgcmVnaW1lLmJyYWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSBicmVhaztcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gYnJhY2tldC50byA/PyBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXhhYmxlID0gTWF0aC5taW4odXBwZXIgLSBicmFja2V0LmZyb20sIHJlbWFpbmluZyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0VGF4ID0gdGF4YWJsZSAqIGJyYWNrZXQucmF0ZTtcbiAgICAgICAgICAgICAgICB0YXggKz0gYnJhY2tldFRheDtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgLT0gdGF4YWJsZTtcblxuICAgICAgICAgICAgICAgIGJyZWFrZG93bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGAke2JyYWNrZXQuZnJvbX1gLFxuICAgICAgICAgICAgICAgICAgICB0bzogYCR7YnJhY2tldC50byA/PyAnQWJvdmUnfWAsXG4gICAgICAgICAgICAgICAgICAgIHJhdGU6IGJyYWNrZXQucmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBicmFja2V0VGF4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB0YXgsIGJyZWFrZG93bnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcmVnaW1lIHR5cGUnKTtcbiAgICB9XG59Il19